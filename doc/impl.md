实现
-----
-----
### **假定**
key长度比较小, 且key的总体占用空间比value的总体占用空间小几个数量级, 场景只需要增删查改的基本操作, 对范围查找的需求不大且对响应时间不敏感(迭代器遍历)
### **架构**
#### 基本操作实现
* 增加 

    用户将k-v条目写入日志文件, k-index条目写入哈希索引备份文件, 并更新内存中的哈希索引

    当文件达到阈值时, 将一次edit(对文件的增加)写入MANIFEST文件中, 更新信息
* 删除

    用户将特定的删除标志写入日志文件, 特定的删除标志写入哈希索引备份文件, 并删除内存中的哈希索引, 增加原索引所在文件的冗余条目数(文件尾部添加一个特定标志)
* 查找

    用户查找内存中的哈希索引, 并读取对应的日志文件
* 迭代器

    遍历整个数据库, 读取所有日志文件
#### 后台存储优化
* 空间压缩(可关闭)

    冗余指数: 日志文件中失效的条目占总条目的比例

    每1s内进行一次空间压缩, STOP THE WORLD, 选择冗余指数最大的两个文件(冗余指数大于等于0.5)进行合并, 将一次edit(对文件的删除和对文件的增加)写入MANIFEST文件中, 删除原文件, 更新信息, START THE WORLD

    *QS: 如何能在空间压缩的过程中同时进行增删查改?*

    *ANS: 有点困难, 涉及到版本之类的东西, 还有冗余指数的计算等等, so, to be simple, we just stop the world*
#### 启动优化

* 在关闭时选择将哈希索引写入新的哈希索引备份文件中
* 在关闭时选择将冗余指数写入指数备份文件中

#### 查询优化

* 使用简单缓存结构(LRU)对最近的查询进行缓存